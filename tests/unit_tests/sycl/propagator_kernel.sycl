/** Detray library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

#include "propagator_kernel.hpp"

namespace detray {

::sycl::queue &get_queue(detray::sycl::queue_wrapper &queue) {

    assert(queue.queue() != nullptr);
    return *(reinterpret_cast<::sycl::queue *>(queue.queue()));
}

const ::sycl::queue &get_queue(const traccc::sycl::queue_wrapper &queue) {

    assert(queue.queue() != nullptr);
    return *(reinterpret_cast<const ::sycl::queue *>(queue.queue()));
}

namespace kernels {
class propagate;
}  // namespace kernels

/// test function for propagator with single state
void propagator_test(
    detector_view<detector_host_type> det_data,
    vecmem::data::vector_view<free_track_parameters<transform3>> &tracks_data,
    vecmem::data::jagged_vector_view<intersection_t> &candidates_data,
    vecmem::data::jagged_vector_view<scalar> &path_lengths_data,
    vecmem::data::jagged_vector_view<vector3> &positions_data,
    vecmem::data::jagged_vector_view<free_matrix> &jac_transports_data,
    sycl::queue_wrapper queue) {

    unsigned int localSize = 64;
    unsigned int globalSize = theta_steps * phi_steps;

    const auto num = (globalSize + localSize - 1) / localSize;
    const auto ndrange = ::sycl::nd_range<1>{::sycl::range<1>(num * localSize),
                                             ::sycl::range<1>(localSize)};

    get_queue(queue)
        .submit([&](::sycl::handler &h) {
            h.parallel_for<kernels::propagate>(
                ndrange,
                [det_data, tracks_data, candidates_data, path_lengths_data,
                 positions_data, jac_transports_data](::sycl::nd_item<1> item) {
                    detector_device_type det(det_data);
                });
        })
        .wait_and_throw();
}

}  // namespace detray